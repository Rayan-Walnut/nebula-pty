<!DOCTYPE html>
<html>

<head>
    <title>Terminal Web</title>
    <link rel="stylesheet" href="/xterm/css/xterm.css" />
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1e1e1e;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        #terminal-container {
            width: 100%;
            height: 90vh;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>
    <div id="terminal-container"></div>

    <script src="/xterm/lib/xterm.js"></script>
    <script src="/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <script>
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: '#1e1e1e',
                foreground: '#ffffff',
                cursor: '#ffffff',
                cursorAccent: '#000000',
                selection: 'rgba(255, 255, 255, 0.3)',
                black: '#000000',
                red: '#ff5555',
                green: '#50fa7b',
                yellow: '#f1fa8c',
                blue: '#bd93f9',
                magenta: '#ff79c6',
                cyan: '#8be9fd',
                white: '#f8f8f2',
                brightBlack: '#6272a4',
                brightRed: '#ff6e6e',
                brightGreen: '#69ff94',
                brightYellow: '#ffffa5',
                brightBlue: '#d6acff',
                brightMagenta: '#ff92df',
                brightCyan: '#a4ffff',
                brightWhite: '#ffffff'
            },
            fontFamily: 'Consolas, "Courier New", monospace',
            fontSize: 14,
            letterSpacing: 0,
            lineHeight: 1.2,
            scrollback: 10000,
            allowTransparency: true
        });

        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);

        term.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        let inputBuffer = '';
        let terminalId = null;
        let isExecutingCommand = false;

        // Connexion WebSocket
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${protocol}//${window.location.host}`);

        // Dans index.html
        ws.onopen = () => {
            console.log('Connecté au serveur WebSocket');
            term.write('\r\nConnecté au terminal...\r\n'); // Ajout d'un message visible
        };
        
        ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);

                switch (message.type) {
                    case 'terminal-id':
                        terminalId = message.id;
                        break;

                    case 'output':
                        term.write(message.data);
                        if (isExecutingCommand && message.data.match(/^[A-Z]:\\.*>/)) {
                            isExecutingCommand = false;
                        }
                        break;

                    default:
                        console.warn('Type de message inconnu:', message.type);
                }
            } catch (err) {
                console.error('Erreur de traitement du message:', err);
            }
        };

        // Gestion des entrées utilisateur
        term.onData(data => {
            if (isExecutingCommand) {
                return; // Ignore les entrées pendant l'exécution d'une commande
            }

            const code = data.charCodeAt(0);

            // Si c'est un retour chariot (Enter)
            if (code === 13) {
                if (inputBuffer.trim()) {
                    isExecutingCommand = true;
                    if (ws.readyState === WebSocket.OPEN && terminalId) {
                        ws.send(JSON.stringify({
                            type: 'input',
                            terminalId: terminalId,
                            data: inputBuffer + '\r\n'
                        }));
                    }
                }
                inputBuffer = '';
            }
            // Si c'est un backspace
            else if (code === 127) {
                if (inputBuffer.length > 0) {
                    inputBuffer = inputBuffer.slice(0, -1);
                    term.write('\b \b');
                }
            }
            // Pour tout autre caractère imprimable
            else if (code >= 32) {
                inputBuffer += data;
                term.write(data);
            }
        });

        // Gestion du redimensionnement
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                fitAddon.fit();
                if (ws.readyState === WebSocket.OPEN && terminalId) {
                    const { cols, rows } = term;
                    ws.send(JSON.stringify({
                        type: 'resize',
                        terminalId: terminalId,
                        cols: cols,
                        rows: rows
                    }));
                }
            }, 100);
        });

        // Gestion des erreurs WebSocket
        ws.onerror = (error) => {
            console.error('Erreur WebSocket:', error);
            term.write('\r\n\x1b[31mErreur de connexion au serveur\x1b[0m\r\n');
        };

        ws.onclose = () => {
            term.write('\r\n\x1b[31mDéconnecté du serveur\x1b[0m\r\n');
        };

        // Activation du focus au démarrage
        term.focus();
    </script>
</body>

</html>